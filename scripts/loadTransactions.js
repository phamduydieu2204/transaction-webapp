// C√ÅCH 2: C·∫£i thi·ªán h√†m loadTransactions trong file loadTransactions.js

import { apiRequestJson } from './apiClient.js';
import { deduplicateRequest } from './core/requestOptimizer.js';
import { getConstants } from './constants.js';

/**
 * Optimized transaction loading with pagination support
 */
export async function loadTransactionsOptimized(userInfo, updateTable, formatDate, editTransaction, deleteTransaction, viewTransaction, options = {}) {
  const {
    page = 1,
    limit = 25,
    useCache = true,
    showProgress = true
  } = options;

  // ‚úÖ Ki·ªÉm tra cache tr∆∞·ªõc
  if (useCache && window.transactionCache && window.transactionCache.page === page && window.transactionCache.limit === limit) {
    // console.log('üì¶ Using cached transaction data for page', page);
    updateTable(window.transactionCache.data, page, limit, formatDate, editTransaction, deleteTransaction, viewTransaction);
    return { status: "success", data: window.transactionCache.data, cached: true };
  }

  // ‚úÖ Ki·ªÉm tra nhanh userInfo tr∆∞·ªõc khi g·ªçi API
  if (!userInfo) {
    console.warn("‚ö†Ô∏è Kh√¥ng c√≥ th√¥ng tin user, b·ªè qua load transactions");
    return { status: "error", message: "Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n vi√™n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i." };
  }

  // console.log(`üîÑ Loading transactions (page ${page}, limit ${limit})...`);
  
  const data = {
    action: "getTransactions",
    maNhanVien: userInfo.maNhanVien,
    vaiTro: userInfo.vaiTro ? userInfo.vaiTro.toLowerCase() : "",
    giaoDichNhinThay: userInfo.giaoDichNhinThay || "",
    nhinThayGiaoDichCuaAi: userInfo.nhinThayGiaoDichCuaAi || "",
    // Add pagination parameters (backend needs to support these)
    page: page,
    limit: limit,
    optimized: true
  };

  try {
    if (showProgress) {
      // Show minimal loading indicator
      const tableBody = document.querySelector('#transactionTable tbody');
      if (tableBody && page === 1) {
        tableBody.innerHTML = '<tr><td colspan="10" class="text-center">üîÑ ƒêang t·∫£i...</td></tr>';
      }
    }

    // Use request deduplication for transactions
    const requestKey = `transactions-${userInfo.maNhanVien}-page${page}-limit${limit}`;
    const result = await deduplicateRequest(
      requestKey,
      async () => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 seconds timeout

        try {
          // Create a custom fetch with timeout since apiRequestJson doesn't support signal
          const response = await Promise.race([
            apiRequestJson(data),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Request timeout')), 10000)
            )
          ]);

          clearTimeout(timeoutId);

          return response;
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }
      },
      { cacheDuration: 2 * 60 * 1000, forceRefresh: !useCache } // 2 minutes cache
    );
    
    if (result.status === "success") {
      const transactions = result.data || [];
      
      // ‚úÖ Cache the result for faster subsequent access
      if (useCache) {
        window.transactionCache = {
          data: transactions,
          page: page,
          limit: limit,
          timestamp: Date.now()
        };
      }

      if (page === 1) {
        // For ultra-fast performance, only keep the requested page
        window.transactionList = transactions;
        window.currentPage = 1;
        window.totalTransactionCount = result.total || transactions.length;
      } else {
        // For subsequent pages, replace data instead of appending
        window.transactionList = transactions;
        window.currentPage = page;
      }
      
      // ‚úÖ Sort transactions by timestamp (newest first)
      window.transactionList.sort((a, b) => {
        const timestampA = (a.transactionId || "").replace(/[^0-9]/g, "");
        const timestampB = (b.transactionId || "").replace(/[^0-9]/g, "");
        return timestampB.localeCompare(timestampA);
      });

      // ‚úÖ Update table only if on transaction tab
      const activeTab = document.querySelector(".tab-content.active");
      const isTransactionTabActive = activeTab && activeTab.id === "tab-giao-dich";
      
      if (isTransactionTabActive || page === 1) {
        // console.log(`üîÑ Updating table with ${transactions.length} transactions (page ${page})`);
        updateTable(window.transactionList, window.currentPage, window.itemsPerPage, formatDate, editTransaction, deleteTransaction, viewTransaction);
      }

      // console.log(`‚úÖ Load transactions successful: ${transactions.length} transactions (page ${page})`);
      return { status: "success", data: transactions, page: page, total: result.total || transactions.length };
      
    } else {
      const errorMsg = result.message || "Kh√¥ng th·ªÉ t·∫£i danh s√°ch giao d·ªãch!";
      console.error("‚ùå L·ªói t·ª´ server:", errorMsg);
      return { status: "error", message: errorMsg };
    }
    
  } catch (err) {
    if (err.name === 'AbortError') {
      console.warn("‚ö†Ô∏è Load transactions b·ªã timeout sau 15 gi√¢y");
      return { status: "error", message: "T·∫£i d·ªØ li·ªáu qu√° l√¢u, vui l√≤ng th·ª≠ l·∫°i" };
    }
    
    const errorMsg = `L·ªói khi t·∫£i danh s√°ch giao d·ªãch: ${err.message}`;
    console.error("‚ùå", errorMsg);
    return { status: "error", message: errorMsg };
  }
}

export async function loadTransactions(userInfo, updateTable, formatDate, editTransaction, deleteTransaction, viewTransaction) {
  // ‚úÖ Ki·ªÉm tra nhanh userInfo tr∆∞·ªõc khi g·ªçi API
  if (!userInfo) {
    console.warn("‚ö†Ô∏è Kh√¥ng c√≥ th√¥ng tin user, b·ªè qua load transactions");
    return { status: "error", message: "Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n vi√™n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i." };
  }

  // console.log("üîÑ B·∫Øt ƒë·∫ßu load transactions...");
  
  const { BACKEND_URL } = getConstants();
  const data = {
    action: "getTransactions",
    maNhanVien: userInfo.maNhanVien,
    vaiTro: userInfo.vaiTro ? userInfo.vaiTro.toLowerCase() : "",
    giaoDichNhinThay: userInfo.giaoDichNhinThay || "",
    nhinThayGiaoDichCuaAi: userInfo.nhinThayGiaoDichCuaAi || ""
  };

  try {
    // ‚úÖ S·ª¨ D·ª§NG TIMEOUT ƒê·ªÇ TR√ÅNH BLOCK UI QU√Å L√ÇU
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 gi√¢y timeout

    const response = await fetch(BACKEND_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data),
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const result = await response.json();
    window.isSearching = false;
    
    if (result.status === "success") {
      window.transactionList = result.data || [];

      // ‚úÖ S·∫Øp x·∫øp giao d·ªãch m·ªõi nh·∫•t l√™n ƒë·∫ßu (timestamp gi·∫£m d·∫ßn)
      window.transactionList.sort((a, b) => {
        const timestampA = (a.transactionId || "").replace(/[^0-9]/g, "");
        const timestampB = (b.transactionId || "").replace(/[^0-9]/g, "");
        return timestampB.localeCompare(timestampA);
      });

      window.currentPage = 1;
      
      // ‚úÖ UPDATE TABLE IF ON TRANSACTION TAB OR IF DATA HAS CHANGED
      const activeTab = document.querySelector(".tab-content.active");
      const activeTabButton = document.querySelector(".tab-button.active");
      const isTransactionTabActive = (activeTab && activeTab.id === "tab-giao-dich") || 
                                   (activeTabButton && activeTabButton.dataset.tab === "tab-giao-dich");
      
      console.log("üîç Tab check:", {
        activeTabId: activeTab ? activeTab.id : "none",
        activeTabButtonData: activeTabButton ? activeTabButton.dataset.tab : "none",
        isTransactionTabActive,
        willUpdateTable: isTransactionTabActive
      });
      
      // ‚úÖ ALWAYS UPDATE TABLE IF WE HAVE TRANSACTION DATA
      if (window.transactionList && window.transactionList.length >= 0) {
        // console.log("üîÑ Updating transaction table with", window.transactionList.length, "transactions");
        updateTable(window.transactionList, window.currentPage, window.itemsPerPage, formatDate, editTransaction, deleteTransaction, viewTransaction);
      } else {
        // console.log("‚ÑπÔ∏è No transaction data to update");
      }

      // console.log("‚úÖ Load transactions th√†nh c√¥ng:", window.transactionList.length, "giao d·ªãch");
      return { status: "success", data: window.transactionList };
      
    } else {
      const errorMsg = result.message || "Kh√¥ng th·ªÉ t·∫£i danh s√°ch giao d·ªãch!";
      console.error("‚ùå L·ªói t·ª´ server:", errorMsg);
      
      // ‚úÖ CH·ªà HI·ªÇN TH·ªä L·ªñI N·∫æU ƒêANG ·ªû TAB GIAO D·ªäCH
      const currentTab = document.querySelector(".tab-button.active");
      if (currentTab && currentTab.dataset.tab === "tab-giao-dich") {
        const errorElement = document.getElementById("errorMessage");
        if (errorElement) {
          errorElement.textContent = errorMsg;
        }
      }
      
      return { status: "error", message: errorMsg };
    }
    
  } catch (err) {
    if (err.name === 'AbortError') {
      console.warn("‚ö†Ô∏è Load transactions b·ªã timeout sau 30 gi√¢y");
      return { status: "error", message: "T·∫£i d·ªØ li·ªáu qu√° l√¢u, vui l√≤ng th·ª≠ l·∫°i" };
    }
    
    const errorMsg = `L·ªói khi t·∫£i danh s√°ch giao d·ªãch: ${err.message}`;
    console.error("‚ùå", errorMsg);
    
    // ‚úÖ CH·ªà HI·ªÇN TH·ªä L·ªñI N·∫æU ƒêANG ·ªû TAB GIAO D·ªäCH
    const currentTab = document.querySelector(".tab-button.active");
    if (currentTab && currentTab.dataset.tab === "tab-giao-dich") {
      const errorElement = document.getElementById("errorMessage");
      if (errorElement) {
        errorElement.textContent = errorMsg;
      }
    }
    
    return { status: "error", message: errorMsg };
  }
}